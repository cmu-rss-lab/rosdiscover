__all__ = ('NavigationPlugin',)

import abc
import typing as t
from typing import Mapping, Type

import attr
from loguru import logger
from roswire.name import canonical_name, namespace_join

from ...interpreter import Interpreter, ModelPlugin, NodeContext


class NavigationPlugin(ModelPlugin):
    # e.g., {name: static_map, type: "costmap_2d::StaticLayer"}
    @classmethod
    def from_dict(cls, dict_: Mapping[str, str],
                  node_name: str,
                  reference_name: t.Optional[str] = None) -> 'NavigationPlugin':
        cpp_class = dict_['type']
        plugin_name = dict_['name']
        logger.debug(f'loading navigation plugin [{plugin_name}] from file [{cpp_class}]')
        cpp_to_cls: Mapping[str, Type[NavigationPlugin]] = {
            'costmap_2d::StaticLayer': StaticLayerPlugin,
            'costmap_2d::FetchDepthLayer': FetchDepthLayerPlugin,
            'costmap_2d::InflationLayer': InflationLayerPlugin,
            'costmap_2d::ObstacleLayer': ObstacleLayerPlugin,
            'costmap_2d::VoxelLayer': VoxelLayerPlugin
        }

        cls = cpp_to_cls[cpp_class]
        plugin = cls.build(plugin_name, node_name, reference_name)
        logger.debug(f'loaded navigation plugin [{plugin_name}] from file [{cpp_class}]: {plugin}')
        return plugin

    @classmethod
    @abc.abstractmethod
    def build(cls, plugin_name: str, node_name: str, reference_name: t.Optional[str]) -> 'NavigationPlugin':
        ...


def get_move_base(i: Interpreter, node_name: str) -> 'NodeContext':
    if not node_name.startswith('/'):
        node_name = f'/{node_name}'
    if node_name not in i.nodes.keys():
        raise ModuleNotFoundError(f'Could not find node {node_name} in configuration')
    move_base = i.nodes[node_name]
    if move_base is None:
        raise ModuleNotFoundError('Could not find node "move_base" in configuration')
    return move_base


@attr.s(frozen=True, slots=True)
class StaticLayerPlugin(NavigationPlugin):
    """
    The static map layer represents a largely unchanging portion of the costmap, like those generated by SLAM.

    http://wiki.ros.org/costmap_2d/hydro/staticmap
    """
    class_name = 'costmap_2d::StaticLayer'
    name: str = attr.ib()
    node_name: str = attr.ib()
    reference_name: t.Optional[str] = attr.ib()

    def load(self, interpreter: Interpreter, c: NodeContext) -> None:
        move_base = c  # get_move_base(interpreter, self.node_name)

        move_base.read('~unknown_cost_value', -1)
        move_base.read('~lethal_cost_value', 100)
        map_topic = move_base.read('~map_topic', '/map')
        move_base.read('~first_map_only', False)
        subscribe_to_updates = move_base.read('~subscribe_to_updates', False)
        move_base.read('~track_unknown_space', True)
        move_base.read('~use_maximum', False)
        move_base.read('~trinary_costmap', True)

        move_base.sub(map_topic, 'nav_msgs/OccupancyGrid')
        if subscribe_to_updates:
            move_base.sub(f'{map_topic}_updates', 'map_msgs/OccupancyGridUpdate')

    @classmethod
    def build(cls, name: str, node_name: str, reference_name: t.Optional[str]) -> NavigationPlugin:
        return StaticLayerPlugin(name=name, node_name=node_name, reference_name=reference_name)


@attr.s(frozen=True, slots=True)
class InflationLayerPlugin(NavigationPlugin):
    """
    The inflation layer is an optimization that adds new values around lethal obstacles (i.e. inflates the obstacles)
    in order to make the costmap represent the configuration space of the robot.

    http://wiki.ros.org/costmap_2d/hydro/inflation
    """
    class_name = 'costmap_2d::InflationLayer'
    name: str = attr.ib()
    node_name: str = attr.ib()
    reference_name: t.Optional[str] = attr.ib()

    def load(self, interpreter: 'Interpreter') -> None:
        move_base = get_move_base(interpreter, self.node_name)
        move_base.read('~inflation_radius', 0.55)
        move_base.read('~cost_scaling_factor', 10.0)

    @classmethod
    def build(cls, name: str, node_name: str, reference_name: t.Optional[str]) -> NavigationPlugin:
        return InflationLayerPlugin(name=name, node_name=node_name, reference_name=reference_name)


@attr.s(frozen=True, slots=True)
class FetchDepthLayerPlugin(NavigationPlugin):
    """
    TODO: This should really be generated

    from /ros_ws/src/fetch_ros/fetch_depth_layer/src/depth_layer.cpp of the Fetch container from TheRobotCooperative
    """
    class_name = 'costmap_2d::FetchDepthLayer'
    name: str = attr.ib()
    node_name: str = attr.ib()
    reference_name: t.Optional[str] = attr.ib()

    def load(self, interpreter: 'Interpreter') -> None:
        move_base = get_move_base(interpreter, self.node_name)

        publish_observations = move_base.read('publish_observations', False)
        move_base.read('~observations_separation_threshold', 0.06)
        move_base.read('~find_ground_plane', True)
        move_base.read('~ground_orientation_threshold', 0.9)
        move_base.read('~min_obstacle_height', 0.0)
        move_base.read('~max_obstacle_height', 2.0)
        move_base.read('~min_clearing_height', float('inf'))
        move_base.read('~max_clearing_height', float('inf'))
        move_base.read('~skip_rays_bottom', 20)
        move_base.read('~skip_rays_top', 20)
        move_base.read('~skip_rays_left', 20)
        move_base.read('~skip_rays_right', 20)
        move_base.read('~clear_with_skipped_rays', False)
        move_base.read('~observation_persistence', 0.0)
        move_base.read('~expected_update_rate', 0.0)
        move_base.read('~transform_tolerance', 0.5)
        move_base.read('~obstacle_range', None)  # TODO is this the right way to handle this?
        move_base.read('~raytrace_range', None)

        if publish_observations:
            move_base.pub('clearing_obs', 'sensor_msgs/PointCloud')
            move_base.pub('marking_obs', 'sensor_msgs/PointCloud')

        depth_topic = move_base.read('depth_topic', '/head_camera/depth_downsample/image_raw')
        info_topic = move_base.read('info_topic', "/head_camera/depth_downsample/camera_info")

        move_base.sub(depth_topic, 'sensor_msgs/Image')
        move_base.sub(info_topic, 'sensor_msgs/CameraInfo')

    @classmethod
    def build(cls, name: str, node_name: str, reference_name: t.Optional[str]) -> 'NavigationPlugin':
        return FetchDepthLayerPlugin(name=name, node_name=node_name, reference_name=reference_name)


@attr.s(frozen=True, slots=True)
class ObstacleLayerPlugin(NavigationPlugin):
    """
    The obstacle layer tracks the obstacles as read by the sensor data. The ObstacleCostmapPlugin marks and raytraces
    obstacles in two dimensions, while the VoxelCostmapPlugin does so in three dimensions.

    http://wiki.ros.org/costmap_2d/hydro/obstacles
    """
    class_name = 'costmap_2d::ObstacleLayer'
    name: str = attr.ib()
    node_name: str = attr.ib()
    reference_name: t.Optional[str] = attr.ib()

    def load(self, interpreter: 'Interpreter') -> None:
        move_base = get_move_base(interpreter, self.node_name)
        top_ns = move_base.name if not self.reference_name else self.reference_name
        observation_sources_param = canonical_name(f"/{top_ns}/{self.name}/observation_sources")
        observation_sources = move_base.read(observation_sources_param, "")

        for os in observation_sources.split(" "):
            if not os:
                continue
            os_ns = f"/{top_ns}/{self.name}/{os}"
            topic = move_base.read(canonical_name(f"{os_ns}/topic"), os)
            move_base.read(namespace_join(os_ns, 'sensor_frame'), "")
            move_base.read(namespace_join(os_ns, 'observation_persistence'), 0.0)
            move_base.read(namespace_join(os_ns, 'expected_update_rate'), 0.0)
            data_type = move_base.read(canonical_name(f"{os_ns}/data_type"), "PointCloud")
            move_base.read(namespace_join(os_ns, 'min_obstacle_height'), 0.0)
            move_base.read(namespace_join(os_ns, 'max_obstacle_height'), 2.0)
            move_base.read(namespace_join(os_ns, 'inf_is_valid'), False)
            move_base.read(namespace_join(os_ns, 'clearing'), False)
            move_base.read(namespace_join(os_ns, 'marking'), True)

            assert data_type in ['PointCloud', 'LaserScan', 'PointCloud2']

            if data_type == 'LaserScan':
                move_base.sub(topic, "sensor_msgs/LaserScan")
            elif data_type == 'PointCloud2':
                move_base.sub(topic, 'sensor_msgs/PointCloud2')
            elif data_type == 'PointCloud':
                move_base.sub(topic, 'sensor_msgs/PointCloud')

    @classmethod
    def build(cls, name: str, node_name: str, reference_name: t.Optional[str]) -> 'NavigationPlugin':
        return ObstacleLayerPlugin(name=name, node_name=node_name, reference_name=reference_name)


@attr.s(frozen=True, slots=True)
class VoxelLayerPlugin(ObstacleLayerPlugin):
    """
    Tracks obstacles in three dimensions
    """
    class_name = "costmap_2d::VoxelLayer"
    name: str = attr.ib()
    node_name: str = attr.ib()
    reference_name: t.Optional[str] = attr.ib()

    def load(self, interpreter: 'Interpreter') -> None:
        ObstacleLayerPlugin.load(self, interpreter)
        move_base = get_move_base(interpreter, self.node_name)
        top_ns = move_base.name if not self.reference_name else self.reference_name
        publish_voxel_sources_param = canonical_name(f"/{top_ns}/{self.name}/publish_voxel_map")
        publish_voxel = move_base.read(publish_voxel_sources_param, False)
        if publish_voxel:
            publish_voxel_topic = canonical_name(f"{top_ns}/{self.name}/voxel_grid")
            move_base.pub(publish_voxel_topic, 'costmap_2d/VoxelGrid')
        clearing_endpoints_topic = canonical_name(f"{top_ns}/{self.name}/clearing_endpoints")
        move_base.pub(f"~{clearing_endpoints_topic}", 'sensor_msgs/PointCloud')

    @classmethod
    def build(cls, name: str, node_name: str, reference_name: t.Optional[str]) -> 'NavigationPlugin':
        return VoxelLayerPlugin(name=name, node_name=node_name, reference_name=reference_name)
